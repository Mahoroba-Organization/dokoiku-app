import { RoomVotes, UserVotes } from './kv';
import { normalizeVote, isNgVote } from './vote_stats';

// Configuration Constants
export const SWITCH_THRESHOLD = 5; // 共通評価店舗数の閾値
export const SCORE_DIFF_THRESHOLD = 10; // Δ: 暫定1位と2位の差
export const CONSECUTIVE_ROUNDS = 10; // R: 連続何回で決定
export const TARGET_EVALUATIONS = 15; // 最低評価数の目安
export const USER_TOP_K = 5;

// Types
export interface Shop {
    id: string;
    name: string;
    genre?: { name?: string };
    [key: string]: any;
}

export interface RankedShop {
    shop: Shop;
    avgScore: number;
    ratedCount: number;
    penaltyApplied: boolean;
    ngExcluded: boolean;
}

/**
 * アクティブ参加者数を計算
 */
export function getParticipantCount(votes: RoomVotes): number {
    return Object.keys(votes).length;
}

/**
 * 共通評価の最低人数を計算
 * min_common = max(3, ceil(0.3 * P))
 */
export function getMinCommon(participantCount: number): number {
    return Math.max(3, Math.ceil(0.3 * participantCount));
}

/**
 * 各店舗の評価人数を計算
 */
function getRatedUserCount(shopId: string, votes: RoomVotes): number {
    let count = 0;
    Object.values(votes).forEach(userVotes => {
        if (userVotes[shopId] !== undefined) {
            count++;
        }
    });
    return count;
}

/**
 * 共通評価された店舗を抽出
 * rated_user_count >= minCommon
 */
export function getCommonShops(shops: Shop[], votes: RoomVotes, minCommon: number): Shop[] {
    return shops.filter(shop => {
        const ratedCount = getRatedUserCount(shop.id, votes);
        return ratedCount >= minCommon;
    });
}

/**
 * ユーザーが評価済みのジャンル集合を計算
 */
export function getUserEvaluatedGenres(userId: string, votes: RoomVotes, shops: Shop[]): Set<string> {
    const genres = new Set<string>();
    const userVotes = votes[userId] || {};

    Object.keys(userVotes).forEach(shopId => {
        const shop = shops.find(s => s.id === shopId);
        if (shop?.genre?.name) {
            genres.add(shop.genre.name);
        }
    });

    return genres;
}

/**
 * ユーザーが未評価の店舗を取得
 */
function getUnevaluatedShops(
    userId: string,
    shops: Shop[],
    votes: RoomVotes,
    excludeShopIds: Set<string> = new Set()
): Shop[] {
    const userVotes = votes[userId] || {};
    return shops.filter(shop => userVotes[shop.id] === undefined && !excludeShopIds.has(shop.id));
}

/**
 * 探索枠: 未評価店舗をランダム選択（ジャンル偏り抑制）
 */
export function getExploreShop(
    userId: string,
    shops: Shop[],
    votes: RoomVotes,
    excludeShopIds: Set<string> = new Set()
): Shop | null {
    const unevaluated = getUnevaluatedShops(userId, shops, votes, excludeShopIds);
    if (unevaluated.length === 0) return null;

    // ジャンル偏り抑制: 評価済みジャンルの少ない店舗を優先
    const evaluatedGenres = getUserEvaluatedGenres(userId, votes, shops);

    // 未評価ジャンルの店舗を優先
    const unevaluatedGenreShops = unevaluated.filter(shop =>
        shop.genre?.name && !evaluatedGenres.has(shop.genre.name)
    );

    const candidates = unevaluatedGenreShops.length > 0 ? unevaluatedGenreShops : unevaluated;

    // ランダム選択
    const randomIndex = Math.floor(Math.random() * candidates.length);
    return candidates[randomIndex];
}

/**
 * 収束枠: 高評価の共通店舗を未評価ユーザーへ配信
 */
export function getExploitShop(
    userId: string,
    shops: Shop[],
    votes: RoomVotes,
    commonShops: Shop[],
    excludeShopIds: Set<string> = new Set()
): Shop | null {
    const userVotes = votes[userId] || {};
    const evaluatedGenres = getUserEvaluatedGenres(userId, votes, shops);

    // 未評価の共通店舗を抽出
    const unevaluatedCommon = commonShops.filter(
        shop => userVotes[shop.id] === undefined && !excludeShopIds.has(shop.id)
    );
    if (unevaluatedCommon.length === 0) return null;

    // 各店舗の平均スコアを計算
    const shopsWithScore = unevaluatedCommon.map(shop => {
        let totalScore = 0;
        let count = 0;

        Object.values(votes).forEach(uv => {
            const stats = normalizeVote(uv[shop.id]);
            if (!stats || stats.ng || stats.count === 0) return;
            totalScore += stats.sum / stats.count;
            count++;
        });

        return {
            shop,
            avgScore: count > 0 ? totalScore / count : 0,
            count
        };
    });

    // 高評価順にソート
    shopsWithScore.sort((a, b) => b.avgScore - a.avgScore);

    // ジャンル考慮で優先順位付け
    // 1. 未評価ジャンルの店舗
    const unevaluatedGenreShops = shopsWithScore.filter(s =>
        s.shop.genre?.name && !evaluatedGenres.has(s.shop.genre.name)
    );

    if (unevaluatedGenreShops.length > 0) {
        return unevaluatedGenreShops[0].shop;
    }

    // 2. その他（評価済みジャンルでも高評価なら配信）
    return shopsWithScore[0]?.shop || null;
}

/**
 * 探索/収束の割合を考慮して次の店舗を選択
 */
export function getNextShop(
    userId: string,
    shops: Shop[],
    votes: RoomVotes,
    excludeShopIds: Set<string> = new Set()
): Shop | null {
    const participantCount = getParticipantCount(votes);
    const minCommon = getMinCommon(participantCount);
    const commonShops = getCommonShops(shops, votes, minCommon);

    // 探索/収束の割合を決定
    const exploreRatio = commonShops.length >= SWITCH_THRESHOLD ? 0.5 : 0.8;

    // ランダムで探索 or 収束を選択
    const isExplore = Math.random() < exploreRatio;

    if (isExplore) {
        const exploreShop = getExploreShop(userId, shops, votes, excludeShopIds);
        if (exploreShop) return exploreShop;
        // 探索枠で見つからなければ収束枠へフォールバック
    }

    const exploitShop = getExploitShop(userId, shops, votes, commonShops, excludeShopIds);
    if (exploitShop) return exploitShop;

    // 収束枠でも見つからなければ探索枠を再試行
    return getExploreShop(userId, shops, votes, excludeShopIds);
}

/**
 * 次の2店舗を取得（ペア提示用）
 */
export function getNextPair(
    userId: string,
    shops: Shop[],
    votes: RoomVotes
): [Shop, Shop] | null {
    const first = getNextShop(userId, shops, votes);
    if (!first) return null;

    const exclude = new Set<string>([first.id]);
    const second = getNextShop(userId, shops, votes, exclude);
    if (!second) return null;

    return [first, second];
}

/**
 * 候補店舗のランキングを計算（A推定ペナルティ適用）
 */
function getUserTopK(userVotes: UserVotes, shops: Shop[], k: number): RankedShop[] {
    const ranked = shops.flatMap(shop => {
        const stats = normalizeVote(userVotes[shop.id]);
        if (!stats || stats.ng || stats.count === 0) return [];
        return [{
            shop,
            avgScore: stats.sum / stats.count,
            ratedCount: stats.count,
            penaltyApplied: false,
            ngExcluded: false
        }];
    });

    ranked.sort((a, b) => {
        if (b.avgScore !== a.avgScore) return b.avgScore - a.avgScore;
        return a.shop.id.localeCompare(b.shop.id);
    });

    return ranked.slice(0, k);
}

function buildGlobalStats(votes: RoomVotes): Map<string, { sum: number; count: number; ratedUsers: number; banned: boolean }> {
    const stats = new Map<string, { sum: number; count: number; ratedUsers: number; banned: boolean }>();

    Object.values(votes).forEach(userVotes => {
        Object.entries(userVotes).forEach(([shopId, entry]) => {
            const current = stats.get(shopId) || { sum: 0, count: 0, ratedUsers: 0, banned: false };
            if (isNgVote(entry)) {
                current.banned = true;
            }
            const normalized = normalizeVote(entry);
            if (normalized && !normalized.ng && normalized.count > 0) {
                current.sum += normalized.sum;
                current.count += normalized.count;
                current.ratedUsers += 1;
            }
            stats.set(shopId, current);
        });
    });

    return stats;
}

export function calculateRanking(
    shops: Shop[],
    votes: RoomVotes,
    _minCommon: number
): RankedShop[] {
    const userIds = Object.keys(votes);
    if (userIds.length === 0) return [];

    const globalStats = buildGlobalStats(votes);
    const candidateIds = new Set<string>();

    userIds.forEach(userId => {
        const userVotes = votes[userId] || {};
        const hasAllRatings = shops.every(shop => userVotes[shop.id] !== undefined);
        if (!hasAllRatings) return;
        const topK = getUserTopK(userVotes, shops, USER_TOP_K);
        topK.forEach(entry => candidateIds.add(entry.shop.id));
    });

    const candidates = Array.from(candidateIds).flatMap(shopId => {
        const shop = shops.find(s => s.id === shopId);
        if (!shop) return [];
        const stats = globalStats.get(shopId);
        if (!stats || stats.banned || stats.count === 0) return [];
        return [{
            shop,
            avgScore: stats.sum / stats.count,
            ratedCount: stats.ratedUsers,
            penaltyApplied: false,
            ngExcluded: false
        }];
    });

    candidates.sort((a, b) => {
        if (b.avgScore !== a.avgScore) return b.avgScore - a.avgScore;
        return a.shop.id.localeCompare(b.shop.id);
    });

    const globalTopK = USER_TOP_K * userIds.length;
    return candidates.slice(0, globalTopK);
}

/**
 * 自動決定条件をチェック
 * 暫定1位が2位に対してΔ点以上の差を連続R回維持したら決定
 */
export function checkAutoDecision(
    rankHistory: Array<{ top1ShopId: string; top2ShopId: string; scoreDiff: number }> | undefined,
    ranking: RankedShop[]
): { decided: boolean; shopId?: string } {
    if (!rankHistory || rankHistory.length < CONSECUTIVE_ROUNDS) {
        return { decided: false };
    }

    if (ranking.length < 2) {
        return { decided: false };
    }

    const top1 = ranking[0];
    const top2 = ranking[1];
    const currentDiff = top1.avgScore - top2.avgScore;

    // 現在の差が閾値未満なら決定しない
    if (currentDiff < SCORE_DIFF_THRESHOLD) {
        return { decided: false };
    }

    // 過去R回の履歴をチェック
    const recentHistory = rankHistory.slice(-CONSECUTIVE_ROUNDS);

    // 全ての履歴で同じ店舗が1位、かつ差が閾値以上か確認
    const allSatisfied = recentHistory.every(h =>
        h.top1ShopId === top1.shop.id && h.scoreDiff >= SCORE_DIFF_THRESHOLD
    );

    if (allSatisfied) {
        return { decided: true, shopId: top1.shop.id };
    }

    return { decided: false };
}
