import { RoomVotes } from './kv';
import { identifyA, NG_SCORE } from './logic';

// Configuration Constants
export const SWITCH_THRESHOLD = 5; // 共通評価店舗数の閾値
export const SCORE_DIFF_THRESHOLD = 10; // Δ: 暫定1位と2位の差
export const CONSECUTIVE_ROUNDS = 10; // R: 連続何回で決定
export const TARGET_EVALUATIONS = 15; // 最低評価数の目安

// Types
export interface Shop {
    id: string;
    name: string;
    genre?: { name?: string };
    [key: string]: any;
}

export interface RankedShop {
    shop: Shop;
    avgScore: number;
    ratedCount: number;
    penaltyApplied: boolean;
    ngExcluded: boolean;
}

/**
 * アクティブ参加者数を計算
 */
export function getParticipantCount(votes: RoomVotes): number {
    return Object.keys(votes).length;
}

/**
 * 共通評価の最低人数を計算
 * min_common = max(3, ceil(0.3 * P))
 */
export function getMinCommon(participantCount: number): number {
    return Math.max(3, Math.ceil(0.3 * participantCount));
}

/**
 * 各店舗の評価人数を計算
 */
function getRatedUserCount(shopId: string, votes: RoomVotes): number {
    let count = 0;
    Object.values(votes).forEach(userVotes => {
        if (userVotes[shopId] !== undefined) {
            count++;
        }
    });
    return count;
}

/**
 * 共通評価された店舗を抽出
 * rated_user_count >= minCommon
 */
export function getCommonShops(shops: Shop[], votes: RoomVotes, minCommon: number): Shop[] {
    return shops.filter(shop => {
        const ratedCount = getRatedUserCount(shop.id, votes);
        return ratedCount >= minCommon;
    });
}

/**
 * ユーザーが評価済みのジャンル集合を計算
 */
export function getUserEvaluatedGenres(userId: string, votes: RoomVotes, shops: Shop[]): Set<string> {
    const genres = new Set<string>();
    const userVotes = votes[userId] || {};

    Object.keys(userVotes).forEach(shopId => {
        const shop = shops.find(s => s.id === shopId);
        if (shop?.genre?.name) {
            genres.add(shop.genre.name);
        }
    });

    return genres;
}

/**
 * ユーザーが未評価の店舗を取得
 */
function getUnevaluatedShops(
    userId: string,
    shops: Shop[],
    votes: RoomVotes,
    excludeShopIds: Set<string> = new Set()
): Shop[] {
    const userVotes = votes[userId] || {};
    return shops.filter(shop => userVotes[shop.id] === undefined && !excludeShopIds.has(shop.id));
}

/**
 * 探索枠: 未評価店舗をランダム選択（ジャンル偏り抑制）
 */
export function getExploreShop(
    userId: string,
    shops: Shop[],
    votes: RoomVotes,
    excludeShopIds: Set<string> = new Set()
): Shop | null {
    const unevaluated = getUnevaluatedShops(userId, shops, votes, excludeShopIds);
    if (unevaluated.length === 0) return null;

    // ジャンル偏り抑制: 評価済みジャンルの少ない店舗を優先
    const evaluatedGenres = getUserEvaluatedGenres(userId, votes, shops);

    // 未評価ジャンルの店舗を優先
    const unevaluatedGenreShops = unevaluated.filter(shop =>
        shop.genre?.name && !evaluatedGenres.has(shop.genre.name)
    );

    const candidates = unevaluatedGenreShops.length > 0 ? unevaluatedGenreShops : unevaluated;

    // ランダム選択
    const randomIndex = Math.floor(Math.random() * candidates.length);
    return candidates[randomIndex];
}

/**
 * 収束枠: 高評価の共通店舗を未評価ユーザーへ配信
 */
export function getExploitShop(
    userId: string,
    shops: Shop[],
    votes: RoomVotes,
    commonShops: Shop[],
    excludeShopIds: Set<string> = new Set()
): Shop | null {
    const userVotes = votes[userId] || {};
    const evaluatedGenres = getUserEvaluatedGenres(userId, votes, shops);

    // 未評価の共通店舗を抽出
    const unevaluatedCommon = commonShops.filter(
        shop => userVotes[shop.id] === undefined && !excludeShopIds.has(shop.id)
    );
    if (unevaluatedCommon.length === 0) return null;

    // 各店舗の平均スコアを計算
    const shopsWithScore = unevaluatedCommon.map(shop => {
        let totalScore = 0;
        let count = 0;

        Object.values(votes).forEach(uv => {
            if (uv[shop.id] !== undefined) {
                totalScore += uv[shop.id];
                count++;
            }
        });

        return {
            shop,
            avgScore: count > 0 ? totalScore / count : 0,
            count
        };
    });

    // 高評価順にソート
    shopsWithScore.sort((a, b) => b.avgScore - a.avgScore);

    // ジャンル考慮で優先順位付け
    // 1. 未評価ジャンルの店舗
    const unevaluatedGenreShops = shopsWithScore.filter(s =>
        s.shop.genre?.name && !evaluatedGenres.has(s.shop.genre.name)
    );

    if (unevaluatedGenreShops.length > 0) {
        return unevaluatedGenreShops[0].shop;
    }

    // 2. その他（評価済みジャンルでも高評価なら配信）
    return shopsWithScore[0]?.shop || null;
}

/**
 * 探索/収束の割合を考慮して次の店舗を選択
 */
export function getNextShop(
    userId: string,
    shops: Shop[],
    votes: RoomVotes,
    excludeShopIds: Set<string> = new Set()
): Shop | null {
    const participantCount = getParticipantCount(votes);
    const minCommon = getMinCommon(participantCount);
    const commonShops = getCommonShops(shops, votes, minCommon);

    // 探索/収束の割合を決定
    const exploreRatio = commonShops.length >= SWITCH_THRESHOLD ? 0.5 : 0.8;

    // ランダムで探索 or 収束を選択
    const isExplore = Math.random() < exploreRatio;

    if (isExplore) {
        const exploreShop = getExploreShop(userId, shops, votes, excludeShopIds);
        if (exploreShop) return exploreShop;
        // 探索枠で見つからなければ収束枠へフォールバック
    }

    const exploitShop = getExploitShop(userId, shops, votes, commonShops, excludeShopIds);
    if (exploitShop) return exploitShop;

    // 収束枠でも見つからなければ探索枠を再試行
    return getExploreShop(userId, shops, votes, excludeShopIds);
}

/**
 * 次の2店舗を取得（ペア提示用）
 */
export function getNextPair(
    userId: string,
    shops: Shop[],
    votes: RoomVotes
): [Shop, Shop] | null {
    const first = getNextShop(userId, shops, votes);
    if (!first) return null;

    const exclude = new Set<string>([first.id]);
    const second = getNextShop(userId, shops, votes, exclude);
    if (!second) return null;

    return [first, second];
}

/**
 * 候補店舗のランキングを計算（A推定ペナルティ適用）
 */
export function calculateRanking(
    shops: Shop[],
    votes: RoomVotes,
    minCommon: number
): RankedShop[] {
    let commonShops = getCommonShops(shops, votes, minCommon);
    if (commonShops.length === 0 && minCommon > 1) {
        commonShops = getCommonShops(shops, votes, 1);
    }

    // A推定
    const aAnalysis = identifyA(votes);
    const aUserId = aAnalysis.aUserId;

    const ranked: RankedShop[] = commonShops.map(shop => {
        let totalScore = 0;
        let count = 0;
        let aVotedNegative = false;
        let hasNg = false;

        Object.entries(votes).forEach(([uid, userVotes]) => {
            const score = userVotes[shop.id];
            if (score !== undefined) {
                totalScore += score;
                count++;

                // A推定: スコア≤25を否定的とみなす
                if (uid === aUserId && score <= 25) {
                    aVotedNegative = true;
                }

                if (score === NG_SCORE) {
                    hasNg = true;
                }
            }
        });

        let avgScore = count > 0 ? totalScore / count : 0;

        // A推定ペナルティ適用
        if (aVotedNegative) {
            avgScore -= 50;
        }

        return {
            shop,
            avgScore,
            ratedCount: count,
            penaltyApplied: aVotedNegative,
            ngExcluded: hasNg
        };
    });

    const eligible = ranked.filter(r => !r.ngExcluded);

    // スコア降順でソート
    eligible.sort((a, b) => {
        if (b.avgScore !== a.avgScore) {
            return b.avgScore - a.avgScore;
        }
        return a.shop.id.localeCompare(b.shop.id);
    });

    return eligible;
}

/**
 * 自動決定条件をチェック
 * 暫定1位が2位に対してΔ点以上の差を連続R回維持したら決定
 */
export function checkAutoDecision(
    rankHistory: Array<{ top1ShopId: string; top2ShopId: string; scoreDiff: number }> | undefined,
    ranking: RankedShop[]
): { decided: boolean; shopId?: string } {
    if (!rankHistory || rankHistory.length < CONSECUTIVE_ROUNDS) {
        return { decided: false };
    }

    if (ranking.length < 2) {
        return { decided: false };
    }

    const top1 = ranking[0];
    const top2 = ranking[1];
    const currentDiff = top1.avgScore - top2.avgScore;

    // 現在の差が閾値未満なら決定しない
    if (currentDiff < SCORE_DIFF_THRESHOLD) {
        return { decided: false };
    }

    // 過去R回の履歴をチェック
    const recentHistory = rankHistory.slice(-CONSECUTIVE_ROUNDS);

    // 全ての履歴で同じ店舗が1位、かつ差が閾値以上か確認
    const allSatisfied = recentHistory.every(h =>
        h.top1ShopId === top1.shop.id && h.scoreDiff >= SCORE_DIFF_THRESHOLD
    );

    if (allSatisfied) {
        return { decided: true, shopId: top1.shop.id };
    }

    return { decided: false };
}
